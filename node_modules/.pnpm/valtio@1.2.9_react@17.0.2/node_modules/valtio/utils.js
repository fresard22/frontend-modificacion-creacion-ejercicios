'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vanilla = require('valtio/vanilla');
var proxyCompare = require('proxy-compare');
var valtio = require('valtio');

var subscribeKey = function subscribeKey(proxyObject, key, callback, notifyInSync) {
  return vanilla.subscribe(proxyObject, function (ops) {
    if (ops.some(function (op) {
      return op[1][0] === key;
    })) {
      callback(proxyObject[key]);
    }
  }, notifyInSync);
};

var currentCleanups;
var watch = function watch(callback, options) {
  var cleanups = new Set();
  var subscriptions = new Set();
  var alive = true;

  var cleanup = function cleanup() {
    cleanups.forEach(function (clean) {
      clean();
    });
    cleanups.clear();
    subscriptions.clear();
  };

  var revalidate = function revalidate() {
    if (!alive) {
      return;
    }

    cleanup();
    var parent = currentCleanups;
    currentCleanups = cleanups;

    try {
      var cleanupReturn = callback(function (proxy) {
        subscriptions.add(proxy);
        return proxy;
      });

      if (cleanupReturn) {
        cleanups.add(cleanupReturn);
      }
    } finally {
      currentCleanups = parent;
    }

    subscriptions.forEach(function (proxy) {
      var clean = vanilla.subscribe(proxy, revalidate, options == null ? void 0 : options.sync);
      cleanups.add(clean);
    });
  };

  var wrappedCleanup = function wrappedCleanup() {
    if (alive) {
      cleanup();
      alive = false;
    }
  };

  if (currentCleanups) {
    currentCleanups.add(wrappedCleanup);
  }

  revalidate();
  return wrappedCleanup;
};

var DEVTOOLS = Symbol();
var devtools = function devtools(proxyObject, name) {
  var extension;

  try {
    extension = window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch (_unused) {}

  if (!extension) {
    if (typeof process === 'object' && process.env.NODE_ENV === 'development' && typeof window !== 'undefined') {
      console.warn('[Warning] Please install/enable Redux devtools extension');
    }

    return;
  }

  var isTimeTraveling = false;
  var devtools = extension.connect({
    name: name
  });
  var unsub1 = vanilla.subscribe(proxyObject, function (ops) {
    var action = ops.filter(function (_ref) {
      _ref[0];
          var path = _ref[1];
      return path[0] !== DEVTOOLS;
    }).map(function (_ref2) {
      var op = _ref2[0],
          path = _ref2[1];
      return op + ":" + path.map(String).join('.');
    }).join(', ');

    if (!action) {
      return;
    }

    if (isTimeTraveling) {
      isTimeTraveling = false;
    } else {
      var snapWithoutDevtools = Object.assign({}, vanilla.snapshot(proxyObject));
      delete snapWithoutDevtools[DEVTOOLS];
      devtools.send({
        type: action,
        updatedAt: new Date().toLocaleString()
      }, snapWithoutDevtools);
    }
  });
  var unsub2 = devtools.subscribe(function (message) {
    var _message$payload3, _message$payload4;

    if (message.type === 'ACTION' && message.payload) {
      try {
        Object.assign(proxyObject, JSON.parse(message.payload));
      } catch (e) {
        console.error('please dispatch a serializable value that JSON.parse() and proxy() support\n', e);
      }
    }

    if (message.type === 'DISPATCH' && message.state) {
      var _message$payload, _message$payload2;

      if (((_message$payload = message.payload) == null ? void 0 : _message$payload.type) === 'JUMP_TO_ACTION' || ((_message$payload2 = message.payload) == null ? void 0 : _message$payload2.type) === 'JUMP_TO_STATE') {
        isTimeTraveling = true;
        var state = JSON.parse(message.state);
        Object.assign(proxyObject, state);
      }
      proxyObject[DEVTOOLS] = message;
    } else if (message.type === 'DISPATCH' && ((_message$payload3 = message.payload) == null ? void 0 : _message$payload3.type) === 'COMMIT') {
      devtools.init(vanilla.snapshot(proxyObject));
    } else if (message.type === 'DISPATCH' && ((_message$payload4 = message.payload) == null ? void 0 : _message$payload4.type) === 'IMPORT_STATE') {
      var _message$payload$next, _message$payload$next2;

      var actions = (_message$payload$next = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next.actionsById;
      var computedStates = ((_message$payload$next2 = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next2.computedStates) || [];
      isTimeTraveling = true;
      computedStates.forEach(function (_ref3, index) {
        var state = _ref3.state;
        var action = actions[index] || 'No action found';
        Object.assign(proxyObject, state);

        if (index === 0) {
          devtools.init(vanilla.snapshot(proxyObject));
        } else {
          devtools.send(action, vanilla.snapshot(proxyObject));
        }
      });
    }
  });
  devtools.init(vanilla.snapshot(proxyObject));
  return function () {
    unsub1();
    unsub2();
  };
};

var subscriptionsCache = new WeakMap();

var getSubscriptions = function getSubscriptions(proxyObject) {
  var subscriptions = subscriptionsCache.get(proxyObject);

  if (!subscriptions) {
    subscriptions = new Map();
    subscriptionsCache.set(proxyObject, subscriptions);
  }

  return subscriptions;
};

var unstable_getDeriveSubscriptions = getSubscriptions;
var derive = function derive(derivedFns, options) {
  var proxyObject = (options == null ? void 0 : options.proxy) || vanilla.proxy({});
  var notifyInSync = options == null ? void 0 : options.sync;
  var subscriptions = getSubscriptions(proxyObject);

  var addSubscription = function addSubscription(p, key, callback) {
    var subscription = subscriptions.get(p);

    if (subscription) {
      subscription[0].set(key, callback);
    } else {
      var unsubscribe = vanilla.subscribe(p, function (ops) {
        var _subscriptions$get;

        if (p === proxyObject && ops.every(function (op) {
          return op[1].length === 1 && op[1][0] in derivedFns;
        })) {
          return;
        }

        (_subscriptions$get = subscriptions.get(p)) == null ? void 0 : _subscriptions$get[0].forEach(function (cb) {
          cb();
        });
      }, notifyInSync);
      subscriptions.set(p, [new Map([[key, callback]]), unsubscribe]);
    }
  };

  var removeSubscription = function removeSubscription(p, key) {
    var subscription = subscriptions.get(p);

    if (subscription) {
      var callbackMap = subscription[0],
          unsubscribe = subscription[1];
      callbackMap.delete(key);

      if (!callbackMap.size) {
        unsubscribe();
        subscriptions.delete(p);
      }
    }
  };

  Object.keys(derivedFns).forEach(function (key) {
    if (Object.getOwnPropertyDescriptor(proxyObject, key)) {
      throw new Error('object property already defined');
    }

    var fn = derivedFns[key];
    var lastDependencies = null;

    var evaluate = function evaluate() {
      if (lastDependencies) {
        if (Array.from(lastDependencies).every(function (_ref) {
          var p = _ref[0],
              n = _ref[1];
          return vanilla.getVersion(p) === n;
        })) {
          return;
        }
      }

      var dependencies = new Map();

      var get = function get(p) {
        dependencies.set(p, vanilla.getVersion(p));
        return p;
      };

      var value = fn(get);

      var subscribe = function subscribe() {
        var _lastDependencies2;

        dependencies.forEach(function (_, p) {
          var _lastDependencies;

          if (!((_lastDependencies = lastDependencies) != null && _lastDependencies.has(p))) {
            addSubscription(p, key, evaluate);
          }
        });
        (_lastDependencies2 = lastDependencies) == null ? void 0 : _lastDependencies2.forEach(function (_, p) {
          if (!dependencies.has(p)) {
            removeSubscription(p, key);
          }
        });
        lastDependencies = dependencies;
      };

      if (value instanceof Promise) {
        value.finally(subscribe);
      } else {
        subscribe();
      }

      proxyObject[key] = value;
    };

    evaluate();
  });
  return proxyObject;
};
var underive = function underive(proxyObject, options) {
  var subscriptions = getSubscriptions(proxyObject);
  var keysToDelete = options != null && options.delete ? new Set() : null;
  subscriptions.forEach(function (_ref2, p) {
    var callbackMap = _ref2[0],
        unsubscribe = _ref2[1];

    if (options != null && options.keys) {
      options.keys.forEach(function (key) {
        if (callbackMap.has(key)) {
          callbackMap.delete(key);

          if (keysToDelete) {
            keysToDelete.add(key);
          }
        }
      });
    } else {
      if (keysToDelete) {
        Array.from(callbackMap.keys()).forEach(function (key) {
          keysToDelete.add(key);
        });
      }

      callbackMap.clear();
    }

    if (!callbackMap.size) {
      unsubscribe();
      subscriptions.delete(p);
    }
  });

  if (keysToDelete) {
    keysToDelete.forEach(function (key) {
      delete proxyObject[key];
    });
  }
};

var addComputed_DEPRECATED = function addComputed_DEPRECATED(proxyObject, computedFns_FAKE, targetObject) {
  if (targetObject === void 0) {
    targetObject = proxyObject;
  }

  console.warn('addComputed is deprecated. Please consider using `derive` or `proxyWithComputed` instead. Falling back to emulation with derive.');
  var derivedFns = {};
  Object.keys(computedFns_FAKE).forEach(function (key) {
    derivedFns[key] = function (get) {
      return computedFns_FAKE[key](get(proxyObject));
    };
  });
  return derive(derivedFns, {
    proxy: targetObject
  });
};

var proxyWithComputed = function proxyWithComputed(initialObject, computedFns) {
  Object.keys(computedFns).forEach(function (key) {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error('object property already defined');
    }

    var computedFn = computedFns[key];

    var _ref = typeof computedFn === 'function' ? {
      get: computedFn
    } : computedFn,
        get = _ref.get,
        set = _ref.set;

    var computedValue;
    var prevSnapshot;
    var affected = new WeakMap();
    var desc = {};

    desc.get = function () {
      var nextSnapshot = vanilla.snapshot(proxyObject);

      if (!prevSnapshot || proxyCompare.isChanged(prevSnapshot, nextSnapshot, affected)) {
        affected = new WeakMap();
        computedValue = get(proxyCompare.createProxy(nextSnapshot, affected));
        prevSnapshot = nextSnapshot;
      }

      return computedValue;
    };

    if (set) {
      desc.set = function (newValue) {
        return set(proxyObject, newValue);
      };
    }

    Object.defineProperty(initialObject, key, desc);
  });
  var proxyObject = vanilla.proxy(initialObject);
  return proxyObject;
};

var proxyWithHistory = function proxyWithHistory(initialValue, skipSubscribe) {
  if (skipSubscribe === void 0) {
    skipSubscribe = false;
  }

  var proxyObject = vanilla.proxy({
    value: initialValue,
    history: vanilla.ref({
      wip: initialValue,
      snapshots: [],
      index: -1
    }),
    canUndo: function canUndo() {
      return proxyObject.history.index > 0;
    },
    undo: function undo() {
      if (proxyObject.canUndo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[--proxyObject.history.index];
        proxyObject.history.snapshots[proxyObject.history.index] = vanilla.snapshot(proxyObject).value;
      }
    },
    canRedo: function canRedo() {
      return proxyObject.history.index < proxyObject.history.snapshots.length - 1;
    },
    redo: function redo() {
      if (proxyObject.canRedo()) {
        proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[++proxyObject.history.index];
        proxyObject.history.snapshots[proxyObject.history.index] = vanilla.snapshot(proxyObject).value;
      }
    },
    saveHistory: function saveHistory() {
      proxyObject.history.snapshots.splice(proxyObject.history.index + 1);
      proxyObject.history.snapshots.push(vanilla.snapshot(proxyObject).value);
      ++proxyObject.history.index;
    },
    subscribe: function subscribe() {
      return vanilla.subscribe(proxyObject, function (ops) {
        if (ops.some(function (op) {
          return op[1][0] === 'value' && (op[0] !== 'set' || op[2] !== proxyObject.history.wip);
        })) {
          proxyObject.saveHistory();
        }
      });
    }
  });
  proxyObject.saveHistory();

  if (!skipSubscribe) {
    proxyObject.subscribe();
  }

  return proxyObject;
};

function _defineEnumerableProperties(obj, descs) {
  for (var key in descs) {
    var desc = descs[key];
    desc.configurable = desc.enumerable = true;
    if ("value" in desc) desc.writable = true;
    Object.defineProperty(obj, key, desc);
  }

  if (Object.getOwnPropertySymbols) {
    var objectSymbols = Object.getOwnPropertySymbols(descs);

    for (var i = 0; i < objectSymbols.length; i++) {
      var sym = objectSymbols[i];
      var desc = descs[sym];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, sym, desc);
    }
  }

  return obj;
}

var proxySet = function proxySet(initialValues) {
  var _Symbol$toStringTag, _proxy, _mutatorMap;

  if (initialValues === void 0) {
    initialValues = [];
  }

  var set = valtio.proxy((_proxy = {
    data: Array.from(new Set(initialValues)),
    has: function has(value) {
      return this.data.indexOf(value) !== -1;
    },
    add: function add(value) {
      var hasProxy = false;

      if (typeof value === 'object' && value !== null) {
        hasProxy = this.data.indexOf(valtio.proxy(value)) !== -1;
      }

      if (this.data.indexOf(value) === -1 && !hasProxy) {
        this.data.push(value);
      }

      return this;
    },
    delete: function _delete(value) {
      var index = this.data.indexOf(value);

      if (index === -1) {
        return false;
      }

      this.data.splice(index, 1);
      return true;
    },
    clear: function clear() {
      this.data.splice(0);
    },

    get size() {
      return this.data.length;
    },

    forEach: function forEach(cb) {
      var _this = this;

      this.data.forEach(function (value) {
        cb(value, value, _this);
      });
    }
  }, _Symbol$toStringTag = Symbol.toStringTag, _mutatorMap = {}, _mutatorMap[_Symbol$toStringTag] = _mutatorMap[_Symbol$toStringTag] || {}, _mutatorMap[_Symbol$toStringTag].get = function () {
    return 'Set';
  }, _proxy.toJSON = function toJSON() {
    return {};
  }, _proxy[Symbol.iterator] = function () {
    return this.data[Symbol.iterator]();
  }, _proxy.values = function values() {
    return this.data.values();
  }, _proxy.keys = function keys() {
    return this.data.values();
  }, _proxy.entries = function entries() {
    return new Set(this.data).entries();
  }, _defineEnumerableProperties(_proxy, _mutatorMap), _proxy));
  Object.defineProperties(set, {
    data: {
      enumerable: false
    },
    size: {
      enumerable: false
    },
    toJSON: {
      enumerable: false
    }
  });
  Object.seal(set);
  return set;
};

exports.addComputed = addComputed_DEPRECATED;
exports.derive = derive;
exports.devtools = devtools;
exports.proxySet = proxySet;
exports.proxyWithComputed = proxyWithComputed;
exports.proxyWithHistory = proxyWithHistory;
exports.subscribeKey = subscribeKey;
exports.underive = underive;
exports.unstable_getDeriveSubscriptions = unstable_getDeriveSubscriptions;
exports.watch = watch;
