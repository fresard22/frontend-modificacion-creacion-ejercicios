System.register(['valtio/vanilla', 'proxy-compare', 'valtio'], (function (exports) {
    'use strict';
    var subscribe, snapshot, proxy, getVersion, ref, createProxy, isChanged, proxy$1;
    return {
        setters: [function (module) {
            subscribe = module.subscribe;
            snapshot = module.snapshot;
            proxy = module.proxy;
            getVersion = module.getVersion;
            ref = module.ref;
        }, function (module) {
            createProxy = module.createProxy;
            isChanged = module.isChanged;
        }, function (module) {
            proxy$1 = module.proxy;
        }],
        execute: (function () {

            const subscribeKey = exports('subscribeKey', (proxyObject, key, callback, notifyInSync) => subscribe(proxyObject, (ops) => {
              if (ops.some((op) => op[1][0] === key)) {
                callback(proxyObject[key]);
              }
            }, notifyInSync));

            let currentCleanups;
            const watch = exports('watch', (callback, options) => {
              const cleanups = /* @__PURE__ */ new Set();
              const subscriptions = /* @__PURE__ */ new Set();
              let alive = true;
              const cleanup = () => {
                cleanups.forEach((clean) => {
                  clean();
                });
                cleanups.clear();
                subscriptions.clear();
              };
              const revalidate = () => {
                if (!alive) {
                  return;
                }
                cleanup();
                const parent = currentCleanups;
                currentCleanups = cleanups;
                try {
                  const cleanupReturn = callback((proxy) => {
                    subscriptions.add(proxy);
                    return proxy;
                  });
                  if (cleanupReturn) {
                    cleanups.add(cleanupReturn);
                  }
                } finally {
                  currentCleanups = parent;
                }
                subscriptions.forEach((proxy) => {
                  const clean = subscribe(proxy, revalidate, options == null ? void 0 : options.sync);
                  cleanups.add(clean);
                });
              };
              const wrappedCleanup = () => {
                if (alive) {
                  cleanup();
                  alive = false;
                }
              };
              if (currentCleanups) {
                currentCleanups.add(wrappedCleanup);
              }
              revalidate();
              return wrappedCleanup;
            });

            const DEVTOOLS = Symbol();
            const devtools = exports('devtools', (proxyObject, name) => {
              let extension;
              try {
                extension = window.__REDUX_DEVTOOLS_EXTENSION__;
              } catch {
              }
              if (!extension) {
                if (typeof process === "object" && process.env.NODE_ENV === "development" && typeof window !== "undefined") {
                  console.warn("[Warning] Please install/enable Redux devtools extension");
                }
                return;
              }
              let isTimeTraveling = false;
              const devtools2 = extension.connect({ name });
              const unsub1 = subscribe(proxyObject, (ops) => {
                const action = ops.filter(([_, path]) => path[0] !== DEVTOOLS).map(([op, path]) => `${op}:${path.map(String).join(".")}`).join(", ");
                if (!action) {
                  return;
                }
                if (isTimeTraveling) {
                  isTimeTraveling = false;
                } else {
                  const snapWithoutDevtools = Object.assign({}, snapshot(proxyObject));
                  delete snapWithoutDevtools[DEVTOOLS];
                  devtools2.send({
                    type: action,
                    updatedAt: new Date().toLocaleString()
                  }, snapWithoutDevtools);
                }
              });
              const unsub2 = devtools2.subscribe((message) => {
                var _a, _b, _c, _d, _e, _f;
                if (message.type === "ACTION" && message.payload) {
                  try {
                    Object.assign(proxyObject, JSON.parse(message.payload));
                  } catch (e) {
                    console.error("please dispatch a serializable value that JSON.parse() and proxy() support\n", e);
                  }
                }
                if (message.type === "DISPATCH" && message.state) {
                  if (((_a = message.payload) == null ? void 0 : _a.type) === "JUMP_TO_ACTION" || ((_b = message.payload) == null ? void 0 : _b.type) === "JUMP_TO_STATE") {
                    isTimeTraveling = true;
                    const state = JSON.parse(message.state);
                    Object.assign(proxyObject, state);
                  }
                  proxyObject[DEVTOOLS] = message;
                } else if (message.type === "DISPATCH" && ((_c = message.payload) == null ? void 0 : _c.type) === "COMMIT") {
                  devtools2.init(snapshot(proxyObject));
                } else if (message.type === "DISPATCH" && ((_d = message.payload) == null ? void 0 : _d.type) === "IMPORT_STATE") {
                  const actions = (_e = message.payload.nextLiftedState) == null ? void 0 : _e.actionsById;
                  const computedStates = ((_f = message.payload.nextLiftedState) == null ? void 0 : _f.computedStates) || [];
                  isTimeTraveling = true;
                  computedStates.forEach(({ state }, index) => {
                    const action = actions[index] || "No action found";
                    Object.assign(proxyObject, state);
                    if (index === 0) {
                      devtools2.init(snapshot(proxyObject));
                    } else {
                      devtools2.send(action, snapshot(proxyObject));
                    }
                  });
                }
              });
              devtools2.init(snapshot(proxyObject));
              return () => {
                unsub1();
                unsub2();
              };
            });

            const subscriptionsCache = /* @__PURE__ */ new WeakMap();
            const getSubscriptions = (proxyObject) => {
              let subscriptions = subscriptionsCache.get(proxyObject);
              if (!subscriptions) {
                subscriptions = /* @__PURE__ */ new Map();
                subscriptionsCache.set(proxyObject, subscriptions);
              }
              return subscriptions;
            };
            const unstable_getDeriveSubscriptions = exports('unstable_getDeriveSubscriptions', getSubscriptions);
            const derive = exports('derive', (derivedFns, options) => {
              const proxyObject = (options == null ? void 0 : options.proxy) || proxy({});
              const notifyInSync = options == null ? void 0 : options.sync;
              const subscriptions = getSubscriptions(proxyObject);
              const addSubscription = (p, key, callback) => {
                const subscription = subscriptions.get(p);
                if (subscription) {
                  subscription[0].set(key, callback);
                } else {
                  const unsubscribe = subscribe(p, (ops) => {
                    var _a;
                    if (p === proxyObject && ops.every((op) => op[1].length === 1 && op[1][0] in derivedFns)) {
                      return;
                    }
                    (_a = subscriptions.get(p)) == null ? void 0 : _a[0].forEach((cb) => {
                      cb();
                    });
                  }, notifyInSync);
                  subscriptions.set(p, [/* @__PURE__ */ new Map([[key, callback]]), unsubscribe]);
                }
              };
              const removeSubscription = (p, key) => {
                const subscription = subscriptions.get(p);
                if (subscription) {
                  const [callbackMap, unsubscribe] = subscription;
                  callbackMap.delete(key);
                  if (!callbackMap.size) {
                    unsubscribe();
                    subscriptions.delete(p);
                  }
                }
              };
              Object.keys(derivedFns).forEach((key) => {
                if (Object.getOwnPropertyDescriptor(proxyObject, key)) {
                  throw new Error("object property already defined");
                }
                const fn = derivedFns[key];
                let lastDependencies = null;
                const evaluate = () => {
                  if (lastDependencies) {
                    if (Array.from(lastDependencies).every(([p, n]) => getVersion(p) === n)) {
                      return;
                    }
                  }
                  const dependencies = /* @__PURE__ */ new Map();
                  const get = (p) => {
                    dependencies.set(p, getVersion(p));
                    return p;
                  };
                  const value = fn(get);
                  const subscribe2 = () => {
                    dependencies.forEach((_, p) => {
                      if (!(lastDependencies == null ? void 0 : lastDependencies.has(p))) {
                        addSubscription(p, key, evaluate);
                      }
                    });
                    lastDependencies == null ? void 0 : lastDependencies.forEach((_, p) => {
                      if (!dependencies.has(p)) {
                        removeSubscription(p, key);
                      }
                    });
                    lastDependencies = dependencies;
                  };
                  if (value instanceof Promise) {
                    value.finally(subscribe2);
                  } else {
                    subscribe2();
                  }
                  proxyObject[key] = value;
                };
                evaluate();
              });
              return proxyObject;
            });
            const underive = exports('underive', (proxyObject, options) => {
              const subscriptions = getSubscriptions(proxyObject);
              const keysToDelete = (options == null ? void 0 : options.delete) ? /* @__PURE__ */ new Set() : null;
              subscriptions.forEach(([callbackMap, unsubscribe], p) => {
                if (options == null ? void 0 : options.keys) {
                  options.keys.forEach((key) => {
                    if (callbackMap.has(key)) {
                      callbackMap.delete(key);
                      if (keysToDelete) {
                        keysToDelete.add(key);
                      }
                    }
                  });
                } else {
                  if (keysToDelete) {
                    Array.from(callbackMap.keys()).forEach((key) => {
                      keysToDelete.add(key);
                    });
                  }
                  callbackMap.clear();
                }
                if (!callbackMap.size) {
                  unsubscribe();
                  subscriptions.delete(p);
                }
              });
              if (keysToDelete) {
                keysToDelete.forEach((key) => {
                  delete proxyObject[key];
                });
              }
            });

            const addComputed_DEPRECATED = exports('addComputed', (proxyObject, computedFns_FAKE, targetObject = proxyObject) => {
              console.warn("addComputed is deprecated. Please consider using `derive` or `proxyWithComputed` instead. Falling back to emulation with derive.");
              const derivedFns = {};
              Object.keys(computedFns_FAKE).forEach((key) => {
                derivedFns[key] = (get) => computedFns_FAKE[key](get(proxyObject));
              });
              return derive(derivedFns, { proxy: targetObject });
            });

            const proxyWithComputed = exports('proxyWithComputed', (initialObject, computedFns) => {
              Object.keys(computedFns).forEach((key) => {
                if (Object.getOwnPropertyDescriptor(initialObject, key)) {
                  throw new Error("object property already defined");
                }
                const computedFn = computedFns[key];
                const { get, set } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
                let computedValue;
                let prevSnapshot;
                let affected = /* @__PURE__ */ new WeakMap();
                const desc = {};
                desc.get = () => {
                  const nextSnapshot = snapshot(proxyObject);
                  if (!prevSnapshot || isChanged(prevSnapshot, nextSnapshot, affected)) {
                    affected = /* @__PURE__ */ new WeakMap();
                    computedValue = get(createProxy(nextSnapshot, affected));
                    prevSnapshot = nextSnapshot;
                  }
                  return computedValue;
                };
                if (set) {
                  desc.set = (newValue) => set(proxyObject, newValue);
                }
                Object.defineProperty(initialObject, key, desc);
              });
              const proxyObject = proxy(initialObject);
              return proxyObject;
            });

            const proxyWithHistory = exports('proxyWithHistory', (initialValue, skipSubscribe = false) => {
              const proxyObject = proxy({
                value: initialValue,
                history: ref({
                  wip: initialValue,
                  snapshots: [],
                  index: -1
                }),
                canUndo: () => proxyObject.history.index > 0,
                undo: () => {
                  if (proxyObject.canUndo()) {
                    proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[--proxyObject.history.index];
                    proxyObject.history.snapshots[proxyObject.history.index] = snapshot(proxyObject).value;
                  }
                },
                canRedo: () => proxyObject.history.index < proxyObject.history.snapshots.length - 1,
                redo: () => {
                  if (proxyObject.canRedo()) {
                    proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[++proxyObject.history.index];
                    proxyObject.history.snapshots[proxyObject.history.index] = snapshot(proxyObject).value;
                  }
                },
                saveHistory: () => {
                  proxyObject.history.snapshots.splice(proxyObject.history.index + 1);
                  proxyObject.history.snapshots.push(snapshot(proxyObject).value);
                  ++proxyObject.history.index;
                },
                subscribe: () => subscribe(proxyObject, (ops) => {
                  if (ops.some((op) => op[1][0] === "value" && (op[0] !== "set" || op[2] !== proxyObject.history.wip))) {
                    proxyObject.saveHistory();
                  }
                })
              });
              proxyObject.saveHistory();
              if (!skipSubscribe) {
                proxyObject.subscribe();
              }
              return proxyObject;
            });

            const proxySet = exports('proxySet', (initialValues = []) => {
              const set = proxy$1({
                data: Array.from(new Set(initialValues)),
                has(value) {
                  return this.data.indexOf(value) !== -1;
                },
                add(value) {
                  let hasProxy = false;
                  if (typeof value === "object" && value !== null) {
                    hasProxy = this.data.indexOf(proxy$1(value)) !== -1;
                  }
                  if (this.data.indexOf(value) === -1 && !hasProxy) {
                    this.data.push(value);
                  }
                  return this;
                },
                delete(value) {
                  const index = this.data.indexOf(value);
                  if (index === -1) {
                    return false;
                  }
                  this.data.splice(index, 1);
                  return true;
                },
                clear() {
                  this.data.splice(0);
                },
                get size() {
                  return this.data.length;
                },
                forEach(cb) {
                  this.data.forEach((value) => {
                    cb(value, value, this);
                  });
                },
                get [Symbol.toStringTag]() {
                  return "Set";
                },
                toJSON() {
                  return {};
                },
                [Symbol.iterator]() {
                  return this.data[Symbol.iterator]();
                },
                values() {
                  return this.data.values();
                },
                keys() {
                  return this.data.values();
                },
                entries() {
                  return new Set(this.data).entries();
                }
              });
              Object.defineProperties(set, {
                data: {
                  enumerable: false
                },
                size: {
                  enumerable: false
                },
                toJSON: {
                  enumerable: false
                }
              });
              Object.seal(set);
              return set;
            });

        })
    };
}));
