const documentTypePartial = `
export type DocumentType<TDocumentNode extends DocumentNode<any, any>> = TDocumentNode extends DocumentNode<
  infer TType,
  any
>
  ? TType
  : never;
`;
const plugin = (_, __, { sourcesWithOperations, useTypeImports }, _info) => {
  if (!sourcesWithOperations)
    return "";
  return [
    `${useTypeImports ? "import type" : "import"} { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';
`,
    `import * as graphql from './graphql';
`,
    `
`,
    ...getDocumentRegistryChunk(sourcesWithOperations),
    `
`,
    ...getGqlOverloadChunk(sourcesWithOperations),
    `
`,
    `export function gql(source: string): DocumentNode | string;
`,
    `export function gql(source: string) {
`,
    `  return (documents as any)[source] || source;
`,
    `}
`,
    documentTypePartial,
    `
export * from 'rq-gql';`,
    `
export * from './graphql';
`
  ].join(``);
};
const EscapedStrings = {};
const escapeString = (str) => EscapedStrings[str] || (EscapedStrings[str] = JSON.stringify(str.replace(/\r\n/g, "\n")));
function getDocumentRegistryChunk(sourcesWithOperations = []) {
  const lines = /* @__PURE__ */ new Set();
  lines.add(`const documents = {
`);
  for (const { operations, ...rest } of sourcesWithOperations) {
    const originalString = rest.source.rawSDL;
    const operation = operations[0];
    if (!originalString || !operation)
      continue;
    lines.add(`    ${escapeString(originalString)}: graphql.${operation.initialName},
`);
  }
  lines.add(`};
`);
  return lines;
}
function getGqlOverloadChunk(sourcesWithOperations) {
  const lines = /* @__PURE__ */ new Set();
  for (const { operations, ...rest } of sourcesWithOperations) {
    const originalString = rest.source.rawSDL;
    if (!originalString)
      continue;
    const escapedOriginalString = escapeString(originalString);
    lines.add(`export function gql(source: ${escapedOriginalString}): (typeof documents)[${escapedOriginalString}];
`);
  }
  return lines;
}

export { escapeString, plugin };
