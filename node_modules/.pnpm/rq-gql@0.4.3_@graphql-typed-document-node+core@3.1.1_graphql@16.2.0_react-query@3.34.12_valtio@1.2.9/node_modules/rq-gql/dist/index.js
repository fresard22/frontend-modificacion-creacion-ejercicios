import { print } from 'graphql/language/printer.js';
import { getOperationAST } from 'graphql/utilities/getOperationAST.js';
import { createContext, createElement, useContext } from 'react';
import { QueryClientProvider, useQuery, useMutation, useInfiniteQuery } from 'react-query';
import { proxy } from 'valtio';

const rqGQLContext = createContext(null);
const useRQGQLContext = () => {
  const ctx = useContext(rqGQLContext);
  if (ctx == null)
    throw Error("rqGQLProvider is not present!");
  return ctx;
};
class RQGQLClient {
  constructor(options) {
    const headers = this.headers = proxy({
      "content-type": "application/json",
      ...options.headers
    });
    const fetchOptions = this.fetchOptions = { ...options.fetchOptions };
    const { endpoint } = options;
    const queryFetcher = options.queryFetcher || (() => {
      if (!endpoint)
        throw Error("Endpoint not specified for rqGQLProvider!");
      return defaultQueryFetcher(endpoint, {
        headers,
        fetchOptions
      });
    })();
    const fetchsOnTheFly = {};
    this.fetchGQL = (queryDoc, variables) => {
      return async () => {
        const queryString = getQueryString(queryDoc);
        const fetchKey = variables ? queryString + JSON.stringify(variables) : queryString;
        const existingFetch = fetchsOnTheFly[fetchKey];
        if (existingFetch)
          return existingFetch;
        try {
          return await (fetchsOnTheFly[fetchKey] = queryFetcher(queryString, variables)());
        } finally {
          delete fetchsOnTheFly[fetchKey];
        }
      };
    };
  }
}
const RQGQLProvider = ({
  children,
  rqGQLClient: value
}) => {
  return createElement(rqGQLContext.Provider, {
    children,
    value
  });
};
const CombinedRQGQLProvider = ({ rqGQLClient, ...reactQuery }) => {
  return createElement(rqGQLContext.Provider, {
    children: createElement(QueryClientProvider, reactQuery),
    value: rqGQLClient
  });
};
const defaultQueryFetcher = (endpoint, { headers, fetchOptions } = {}) => (query, variables) => {
  return async () => {
    const res = await fetch(endpoint, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        ...headers
      },
      body: JSON.stringify({ query, variables }),
      ...fetchOptions
    });
    const { errors, data } = await res.json();
    if (errors == null ? void 0 : errors.length) {
      if (errors.length > 1) {
        const err = Error("Multiple Errors");
        for (const err2 of errors) {
          console.error(err2);
        }
        Object.assign(err, {
          graphqlErrors: errors
        });
        throw err;
      }
      const { message } = errors[0];
      throw new Error(message);
    }
    return data;
  };
};
const documentPrintCache = /* @__PURE__ */ new WeakMap();
function getQueryString(doc) {
  if (typeof doc === "string")
    return doc;
  let queryString = documentPrintCache.get(doc);
  if (queryString == null) {
    queryString = print(doc);
    documentPrintCache.set(doc, queryString);
  }
  return queryString;
}
const operationASTCache = /* @__PURE__ */ new WeakMap();
function getKey(queryDoc, variables) {
  var _a, _b;
  let key;
  if (typeof queryDoc === "string") {
    key = queryDoc;
  } else {
    let astCacheValue = operationASTCache.get(queryDoc);
    if (astCacheValue) {
      key = astCacheValue;
    } else if (astCacheValue === void 0) {
      astCacheValue = ((_b = (_a = getOperationAST(queryDoc)) == null ? void 0 : _a.name) == null ? void 0 : _b.value) || null;
      operationASTCache.set(queryDoc, astCacheValue);
      key = astCacheValue || getQueryString(queryDoc);
    } else {
      key = getQueryString(queryDoc);
    }
  }
  return variables == null ? [key] : [key, variables];
}
function useGQLQuery(queryDoc, variables, options) {
  const { fetchGQL } = useRQGQLContext();
  return useQuery(getKey(queryDoc, variables), fetchGQL(queryDoc, variables), options);
}
function useGQLMutation(queryDoc, options) {
  const { fetchGQL } = useRQGQLContext();
  return useMutation((variables) => fetchGQL(queryDoc, variables)(), options);
}
function useGQLInfiniteQuery(queryDoc, getVariables, options) {
  const { fetchGQL } = useRQGQLContext();
  return useInfiniteQuery((options == null ? void 0 : options.queryKey) || getKey(queryDoc), ({ pageParam }) => {
    return fetchGQL(queryDoc, getVariables(pageParam))();
  }, options);
}

export { CombinedRQGQLProvider, RQGQLClient, RQGQLProvider, defaultQueryFetcher, getKey, rqGQLContext, useGQLInfiniteQuery, useGQLMutation, useGQLQuery };
